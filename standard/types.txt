# Type-checking and normalization

## Summary

Dhall's type system is System Fω implemented using a pure type system.  Type
abstraction and type application are explicit and not inferred.  Dhall also
supports additional built-in functions, operators, and constants for efficiency.

Dhall also supports referencing shadowed variables through the use of DeBruijn
indices.  This document spells out in detail how to implement these
DeBruijn-like variable references.

## Expressions

The following notation is a simplified version of the syntax found in
`./dhall.abnf`.  This simplified notation is used for all of the following
judgments:

```
m, n = +0 / +1 + n     ; Natural numbers

d = n / -n             ; Integers

"…" = "" / "." ++ "…"  ; Text ("." is any character and "…" is any string)

x, y                   ; Variables

; Mnemonics:
;
; Terms are lowercase:
;
;     a    = input term whose type is "A"
;     b    = output term whose type is "B"
;     f    = "f"unction
;     l, r = "l"eft and "r"ight term that share the same type
;     e    = term whose type is "E"
;     t    = term whose type is "T"
;     u    = term whose type is "U"
;
; Types are uppercase:
;
;     A  = type of the input term "a"
;     B  = type of the output term "b"
;     L  = type of the input term "l"
;     R  = type of the output term "r"
;     E  = type of the term "e"
;     T  = type of the term "t"
;     U  = type of the term "u"
;
; Kinds are lowercase:
;
;     k = "k"ind
;     i = kind of a function's "i"nput type
;     o = kind of a function's "o"utput type
;
; Note that these are only informal mnemonics.  Dhall is a pure type system,
; which means that many places in the syntax permit types, terms, and kinds.
; The typing judgments are the authoritative rules for what expressions are
; permitted and forbidden.
a, b, f, l, r, e, t, u, A, B, L, R, E, T, U, k, i, o
  = x@n                      ; Identifier
                             ; (`x` is short-hand for `x@0`)
  / λ(x : A) → b             ; Anonymous function
  / ∀(x : A) → B             ; Function type
                             ; (`A → B` is short-hand for `∀(_ : A) → B`)
  / let x : A = a in b       ; Let expression with type annotation
  / let x     = a in b       ; Let expression without type annotation
  / if t then l else r       ; If-Then-Else expression
  / merge t u : T            ; Union elimination with type annotation
  / merge t u                ; Union elimination
  / [] : List T              ; Empty list literals with type annotation
  / [ t, … ]                 ; Non-empty list literals
  / [   ] : Optional T       ; Empty optional literal
  / [ t ] : Optional T       ; Non-empty optional literal
  / t : T                    ; Type annotation
  / l || r                   ; Boolean or
  / l + r                    ; Natural addition
  / l ++ r                   ; Text append
  / l # r                    ; List append
  / l && r                   ; Boolean and
  / l ∧ r                    ; Recursive record merge
  / l ⫽ r                    ; Non-recursive right-biased record merge
  / l * r                    ; Natural multiplication
  / l == r                   ; Boolean equality
  / l != r                   ; Boolean inequality
  / f a                      ; Function application
  / n.n                      ; Double-precision floating point literal
  / +n                       ; Natural number literal
  / n                        ; Integer literal
  / "…"                      ; Text literal
  / { x : T, … }             ; Record type
  / { x = t, … }             ; Non-empty record literal
  / < x : T | … >            ; Union type
  / < x = t | y : T | … >    ; Union literal
  / Natural/build            ; Natural introduction
  / Natural/fold             ; Natural elimination
  / Natural/isZero           ; Test if zero
  / Natural/even             ; Test if even
  / Natural/odd              ; Test if odd
  / Natural/toInteger        ; Convert Natural to Integer
  / Natural/show             ; Convert Natural to Text
  / Integer/show             ; Convert Integer to Text
  / Double/show              ; Convert Double to Text
  / List/build               ; List introduction
  / List/fold                ; List elimination
  / List/length              ; Length of list
  / List/head                ; First element of list
  / List/last                ; Last element of list
  / List/indexed             ; Tag elements with index
  / List/reverse             ; Reverse list
  / Optional/fold            ; Optional introduction
  / Optional/build           ; Optional elimination
  / Bool                     ; Bool type
  / Optional                 ; Optional type
  / Natural                  ; Natural type
  / Integer                  ; Integer type
  / Double                   ; Double type
  / Text                     ; Text type
  / List                     ; List type
  / True                     ; True term
  / False                    ; False term
  / Type                     ; Type of terms
  / Kind                     ; Type of types
```

Carefully note that the syntax does not include imports because you cannot infer
the type of a Dhall expression that has unresolved imports.  In other words,
import resolution is a distinct phase that must precede type checking and type
inference.

## Shift

Dhall allows variables to reference shadowed variables of the same name using De
Bruijn indices.  For example:


                                  ┌──refers to──┐
                                  │             │
                                  ↓             │
    λ(x : Type) → λ(y : Type) → λ(x : Type) → x@0


      ┌────────────────refers to────────────────┐
      │                                         │
      ↓                                         │
    λ(x : Type) → λ(y : Type) → λ(x : Type) → x@1


To be precise, `x@n` refers to the "nth" bound variable named `x` counting
outwards from where the variable is referenced.

If a variable does not specify the De Bruijn index (i.e. just `x`) then the De
Bruijn index defaults to 0 (i.e. `x@0`), like this:


                                  ┌─refers to─┐
                                  │           │
                                  ↓           │
    λ(x : Type) → λ(y : Type) → λ(x : Type) → x



Dhall uses a shift function internally to avoid variable capture in the
implementation of De Bruijn indices.  This function increases or decreases the
indices of free variables within an expression.

This shift function has the form:

    ↑(d, x, m, e₀) = e₁

... where:

* `d` is the amount to add to the variable indices
    * `d` is always `-1` or `1`
* `x` is is the name of the free variable(s) to shift
    * variables with a different name are unaffected by the shift function
* `m` is the minimum index to shift
    * `m` always starts out at `0`
    * `m` increases by one when descending past a bound variable named `x`
    * variables with an index lower than `m` are unaffected by the shift
      function
* `e₀` is the expression to shift
* `e₁` is the shifted expression

For example:

    ↑(1, x, 0, x) = x@1

    ↑(1, x, 1, x) = x

    ↑(1, x, 0, y) = y

    ↑(-1, x, 0, x@1) = x

    ↑(1, x, 0, List x) = List x@1

### Variables

The first rule is that the shift function will increase the index of any
variable if the variable name matches and the variable's index is greater than
or equal to the minimum index to shift:


    ───────────────────────────  ; m <= n
    ↑(d, x, m, x@n) = x@(n + d)


We don't shift the index if the index falls short of the lower bound or if the
variable name does not match:


    ─────────────────────  ; m > n
    ↑(d, x, m, x@n) = x@n


    ─────────────────────  ; x ≠ y
    ↑(d, x, m, x@n) = y@n


### Bound variables

The shift function is designed to shift only free variables.  For example, the
shift function should have no effect on a closed expression:

    ↑(1, x, 0, λ(x : Type) → x) = λ(x : Type) → x

This implies that we must increment the minimum bound when we descend into a
λ-expression that binds a variable of the same name in order to avoid shifting
the bound variable:


    ↑(d, x, m, A₀) = A₁   ↑(d, x, m + 1, b₀) = b₁
    ─────────────────────────────────────────────
    ↑(d, x, m, λ(x : A₀) → b₀) = λ(x : A₁) → b₁


... otherwise we descend as normal if the bound variable name does not match:


    ↑(d, x, m, A₀) = A₁   ↑(d, x, m, b₀) = b₁
    ───────────────────────────────────────────  ; x ≠ y
    ↑(d, x, m, λ(y : A₀) → b₀) = λ(y : A₁) → b₁


Similarly, we increase the minimum bound when we descend into a function type
that binds a variable of the same name:


    ↑(d, x, m, A₀) = A₁   ↑(d, x, m + 1, B₀) = B₁
    ─────────────────────────────────────────────
    ↑(d, x, m, ∀(x : A₀) → B₀) = ∀(x : A₁) → B₁


... otherwise we descend as normal if the bound variable name does not match:


    ↑(d, x, m, A₀) = A₁   ↑(d, x, m, B₀) = B₁
    ───────────────────────────────────────────  ; x ≠ y
    ↑(d, x, m, ∀(y : A₀) → B₀) = ∀(y : A₁) → B₁


Similarly, we increase the minimum bound when descending into a `let` expression
that binds a variable of the same name:


    ↑(d, x, m, A₀) = A₁   ↑(d, x, m, a₀) = a₁   ↑(d, x, m + 1, b₀) = b₁
    ───────────────────────────────────────────────────────────────────
    ↑(d, x, m, let x : A₀ = a₀ in b₀) = let x : A₁ = a₁ in b₁


    ↑(d, x, m, a₀) = a₁   ↑(d, x, m + 1, b₀) = b₁
    ───────────────────────────────────────────────
    ↑(d, x, m, let x = a₀ in b₀) = let x = a₁ in b₁


... otherwise we descend as normal if the bound variable name does not match:


    ↑(d, x, m, A₀) = A₁   ↑(d, x, m, a₀) = a₁   ↑(d, x, m, b₀) = b₁
    ───────────────────────────────────────────────────────────────  ; x ≠ y
    ↑(d, x, m, let y : A₀ = a₀ in b₀) = let y : A₁ = a₁ in b₁


    ↑(d, x, m, a₀) = a₁   ↑(d, x, m, b₀) = b₁
    ───────────────────────────────────────────────  ; x ≠ y
    ↑(d, x, m, let y = a₀ in b₀) = let y = a₁ in b₁


Note that Dhall's `let` expressions do not allow recursive definitions so the
bound variable is not in scope for the right-hand side of the assignment (i.e.
`a₀` in the above rules).  Therefore we do not need to shift the minimum index
when descending into the right-hand side of the `let` expression.

### Induction

No other Dhall expressions bind variables, so the remaining rules just descend
as normal:


    ↑(d, x, m, t₀) = t₁   ↑(d, x, m, l₀) = l₁   ↑(d, x, m, r₀) = r₁
    ───────────────────────────────────────────────────────────────
    ↑(d, x, m, if t₀ then l₀ else r₀) = if t₁ then l₁ else r₁


    ↑(d, x, m, t₀) = t₁   ↑(d, x, m, u₀) = u₁   ↑(d, x, m, T₀) = T₁
    ───────────────────────────────────────────────────────────────
    ↑(d, x, m, merge t₀ u₀ : T₀) = merge t₁ u₁ : T₁


    ↑(d, x, m, t₀) = t₁   ↑(d, x, m, u₀) = u₁
    ─────────────────────────────────────────
    ↑(d, x, m, merge t₀ u₀) = merge t₁ u₁


    ↑(d, x, m, T₀) = T₁
    ───────────────────────────────────────
    ↑(d, x, m, [] : List T₀) = [] : List T₁


    ↑(d, x, m, t₀) = t₁   …
    ─────────────────────────────────
    ↑(d, x, m, [ t₀, … ]) = [ t₁, … ]


    ↑(d, x, m, T₀) = T₁
    ───────────────────────────────────────────────
    ↑(d, x, m, [] : Optional T₀) = [] : Optional T₁


    ↑(d, x, m, t₀) = t₁   ↑(d, x, m, T₀) = T₁
    ───────────────────────────────────────────────────────
    ↑(d, x, m, [ t₀ ] : Optional T₀) = [ t₁ ] : Optional T₁


    ↑(d, x, m, t₀) = t₁   ↑(d, x, m, T₀) = T₁
    ─────────────────────────────────────────
    ↑(d, x, m, t₀ : T₀) = t₁ : T₁


    ↑(d, x, m, l₀) = l₁   ↑(d, x, m, r₀) = r₁
    ─────────────────────────────────────────
    ↑(d, x, m, l₀ || r₀) = l₁ || r₁


    ↑(d, x, m, l₀) = l₁   ↑(d, x, m, r₀) = r₁
    ─────────────────────────────────────────
    ↑(d, x, m, l₀ + r₀) = l₁ + r₁


    ↑(d, x, m, l₀) = l₁   ↑(d, x, m, r₀) = r₁
    ─────────────────────────────────────────
    ↑(d, x, m, l₀ ++ r₀) = l₁ ++ r₁


    ↑(d, x, m, l₀) = l₁   ↑(d, x, m, r₀) = r₁
    ─────────────────────────────────────────
    ↑(d, x, m, l₀ # r₀) = l₁ # r₁


    ↑(d, x, m, l₀) = l₁   ↑(d, x, m, r₀) = r₁
    ─────────────────────────────────────────
    ↑(d, x, m, l₀ && r₀) = l₁ && r₁


    ↑(d, x, m, l₀) = l₁   ↑(d, x, m, r₀) = r₁
    ─────────────────────────────────────────
    ↑(d, x, m, l₀ ∧ r₀) = l₁ ∧ r₁


    ↑(d, x, m, l₀) = l₁   ↑(d, x, m, r₀) = r₁
    ─────────────────────────────────────────
    ↑(d, x, m, l₀ ⫽ r₀) = l₁ ⫽ r₁


    ↑(d, x, m, l₀) = l₁   ↑(d, x, m, r₀) = r₁
    ─────────────────────────────────────────
    ↑(d, x, m, l₀ * r₀) = l₁ * r₁


    ↑(d, x, m, l₀) = l₁   ↑(d, x, m, r₀) = r₁
    ─────────────────────────────────────────
    ↑(d, x, m, l₀ == r₀) = l₁ == r₁


    ↑(d, x, m, l₀) = l₁   ↑(d, x, m, r₀) = r₁
    ─────────────────────────────────────────
    ↑(d, x, m, l₀ != r₀) = l₁ != r₁


    ↑(d, x, m, f₀) = f₁   ↑(d, x, m, a₀) = a₁
    ─────────────────────────────────────────
    ↑(d, x, m, f₀ a₀) = f₁ a₁


    ─────────────────────
    ↑(d, x, m, n.n) = n.n


    ───────────────────
    ↑(d, x, m, +n) = +n


    ─────────────────
    ↑(d, x, m, n) = n


    ─────────────────────
    ↑(d, x, m, "…") = "…"


    ↑(d, x, m, T₀) = T₁   …
    ─────────────────────────────────────────
    ↑(d, x, m, { x : T₀, … }) = { x : T₁, … }


    ↑(d, x, m, t₀) = t₁   …
    ─────────────────────────────────────────
    ↑(d, x, m, { x = t₀, … }) = { x = t₁, … }


    ↑(d, x, m, T₀) = T₁   …
    ───────────────────────────────────────────
    ↑(d, x, m, < x : T₀ | … >) = < x : T₁ | … >


    ↑(d, x, m, t₀) = t₁   ↑(d, x, m, T₀) = T₁   …
    ─────────────────────────────────────────────────────────────
    ↑(d, x, m, < x = t₀ | y : T₀ | … >) = < x = t₁ | y : T₁ | … >


    ─────────────────────────────────────────
    ↑(d, x, m, Natural/build) = Natural/build


    ───────────────────────────────────────
    ↑(d, x, m, Natural/fold) = Natural/fold


    ───────────────────────────────────────────
    ↑(d, x, m, Natural/isZero) = Natural/isZero


    ───────────────────────────────────────
    ↑(d, x, m, Natural/even) = Natural/even


    ─────────────────────────────────────
    ↑(d, x, m, Natural/odd) = Natural/odd


    ─────────────────────────────────────────────────
    ↑(d, x, m, Natural/toInteger) = Natural/toInteger


    ───────────────────────────────────────
    ↑(d, x, m, Natural/show) = Natural/show


    ───────────────────────────────────────
    ↑(d, x, m, Integer/show) = Integer/show


    ─────────────────────────────────────
    ↑(d, x, m, Double/show) = Double/show


    ───────────────────────────────────
    ↑(d, x, m, List/build) = List/build


    ─────────────────────────────────
    ↑(d, x, m, List/fold) = List/fold


    ─────────────────────────────────────
    ↑(d, x, m, List/length) = List/length


    ─────────────────────────────────
    ↑(d, x, m, List/head) = List/head


    ─────────────────────────────────
    ↑(d, x, m, List/last) = List/last


    ───────────────────────────────────────
    ↑(d, x, m, List/indexed) = List/indexed


    ───────────────────────────────────────
    ↑(d, x, m, List/reverse) = List/reverse


    ─────────────────────────────────────────
    ↑(d, x, m, Optional/fold) = Optional/fold


    ───────────────────────────────────────────
    ↑(d, x, m, Optional/build) = Optional/build


    ───────────────────────
    ↑(d, x, m, Bool) = Bool


    ───────────────────────────────
    ↑(d, x, m, Optional) = Optional


    ─────────────────────────────
    ↑(d, x, m, Natural) = Natural


    ─────────────────────────────
    ↑(d, x, m, Integer) = Integer


    ───────────────────────────
    ↑(d, x, m, Double) = Double


    ───────────────────────
    ↑(d, x, m, Text) = Text


    ───────────────────────
    ↑(d, x, m, List) = List


    ───────────────────────
    ↑(d, x, m, True) = True


    ─────────────────────────
    ↑(d, x, m, False) = False


    ───────────────────────
    ↑(d, x, m, Type) = Type


    ───────────────────────
    ↑(d, x, m, Kind) = Kind


## Contexts

The syntax of contexts is:

    Γ = ε         ; The empty context
      / Γ, x : E  ; A context extended with a type annotation for a variable

Contexts are ordered and there can be multiple type annotations in the context
for the same variable.

## Shift context

You can also shift a context by shifting each expression in that context:

    ─────────────────
    ↑(d, x, m, ε) = ε


    ↑(d, x, m, Γ₀) = Γ₁   ↑(d, x, m, E₀) = E₁
    ─────────────────────────────────────────
    ↑(d, x, m, (Γ₀, x : E₀)) = Γ₁, x : E₁


## Substitution

β-reduction requires support for substitution, which has the following form:

    e₀[x@n ≔ a] = e₁

... where:

* `e₀` is the expression that you want to transform
* `x@n` is the variable that you want to substitute with another expression
* `a` is the expression that you want to substitute `x@n` with
* `e₁` is transformed expression where all occurrences of `x@n` have been
  replaced with `a`

`e[x ≔ a]` is short-hand for `e[x@0 ≔ a]`

For example:

    x[x ≔ Bool] = Bool

    y[x ≔ Bool] = y

    (List x)[x ≔ Bool] = List Bool

### Variables

Like shifting, we only need to pay special attention to the cases where we
bind variables or reference variables.

The first two rules govern when we can substitute a variable with the specified
expression:


    ────────────────
    x@n[x@n ≔ e] = e


    ──────────────────  ; x@n ≠ y@m
    y@m[x@n ≔ e] = y@m


In other words, we substitute the expression if the variable name and index
exactly match, but otherwise we do not substitute and leave the variable as-is.

### Bound variables

The substitution function is designed to only substitute free variables and
ignore bound variables.  The following few examples can help build an intuition
for how substitution uses the numeric index of the variable that we are
substituting for:

    (λ(x : Text) → x)[x ≔ True] = λ(x : Text) → x

    (λ(y : Text) → x)[x ≔ True] = λ(x : Text) → True

    (λ(x : Text) → x@1)[x ≔ True] = λ(x : Text) → True

    (λ(x : Text) → x@2)[x@1 ≔ True] = λ(x : Text) → True

    (λ(x : Text) → λ(x : Text) → x@3)[x@1 ≔ True] = λ(x : Text) → λ(x : Text) → True

We ensure that we only substitute free variables by increasing the index when a
new bound variable of the same name is in scope:


    …   b₀[x@(+1 + n) ≔ e₁] = b₁   …
    ────────────────────────────────
    …


We also take care to avoid variable capture by shifting variables within the
expression that we substitute, like this:

    (λ(x : Type) → y)[y ≔ x] = λ(x : Type) → x@1

We avoid variable capture by shifting the expression to substitute when any new
bound variable is in scope, like this:


    …   ↑(1, x, 0, e₀) = e₁   …
    ───────────────────────────
    …


All of the following rules cover expressions that can bind variables:


    A₀[x@n ≔ e₀] = A₁   ↑(1, x, 0, e₀) = e₁   b₀[x@(+1 + n) ≔ e₁] = b₁
    ──────────────────────────────────────────────────────────────────
    (λ(x : A₀) → b₀)[x@n ≔ e₀] = λ(x : A₁) → b₁


    A₀[x@n ≔ e₀] = A₁   ↑(1, y, 0, e₀) = e₁   b₀[x@n ≔ e₁] = b₁
    ───────────────────────────────────────────────────────────  ; x ≠ y
    (λ(y : A₀) → b₀)[x@n ≔ e₀] = λ(y : A₁) → b₁


    A₀[x@n ≔ e₀] = A₁   ↑(1, x, 0, e₀) = e₁   B₀[x@(+1 + n) ≔ e₁] = B₁
    ──────────────────────────────────────────────────────────────────
    (∀(x : A₀) → B₀)[x@n ≔ e₀] = ∀(x : A₁) → B₁


    A₀[x@n ≔ e₀] = A₁   ↑(1, y, 0, e₀) = e₁   B₀[x@n ≔ e₁] = B₁
    ───────────────────────────────────────────────────────────  ; x ≠ y
    (∀(y : A₀) → B₀)[x@n ≔ e₀] = ∀(y : A₁) → B₁


    A₀[x@n ≔ e₀] = A₁
    a₀[x@n ≔ e₀] = a₁
    ↑(1, x, 0, e₀) = e₁
    b₀[x@(+1 + n) ≔ e₁] = b₁
    ─────────────────────────────────────────────────────────
    (let x : A₀ = a₀ in b₀)[x@n ≔ e₀] = let x : A₁ = a₁ in b₁


    A₀[x@n ≔ e₀] = A₁
    a₀[x@n ≔ e₀] = a₁
    ↑(1, y, 0, e₀) = e₁
    b₀[x@n ≔ e₁] = b₁
    ─────────────────────────────────────────────────────────  ; x ≠ y
    (let y : A₀ = a₀ in b₀)[x@n ≔ e₀] = let y : A₁ = a₁ in b₁


    a₀[x@n ≔ e₀] = a₁   ↑(1, x, 0, e₀) = e₁   b₀[x@(+1 + n) ≔ e₁] = b₁
    ──────────────────────────────────────────────────────────────────
    (let x = a₀ in b₀)[x@n ≔ e₀] = let x = a₁ in b₁


    a₀[x@n ≔ e₀] = a₁   ↑(1, y, 0, e₀) = e₁   b₀[x@n ≔ e₁] = b₁
    ───────────────────────────────────────────────────────────  ; x ≠ y
    (let y = a₀ in b₀)[x@n ≔ e₀] = let y = a₁ in b₁


### Induction

No other Dhall expressions bind variables, so the remaining rules just descend
as normal:


    t₀[x@n ≔ e] = t₁   l₀[x@n ≔ e] = l₁   r₀[x@n ≔ e] = r₁
    ────────────────────────────────────────────────────────
    (if t₀ then l₀ else r₀)[x@n ≔ e] = if t₁ then l₁ else r₁


    t₀[x@n ≔ e] = t₁   u₀[x@n ≔ e] = u₁   T₀[x@n ≔ e] = T₁
    ──────────────────────────────────────────────────────
    (merge t₀ u₀ : T₀)[x@n ≔ e] = merge t₁ u₁ : T₁


    t₀[x@n ≔ e] = t₁   u₀[x@n ≔ e] = u₁
    ────────────────────────────────────
    (merge t₀ u₀)[x@n ≔ e] = merge t₁ u₁


    T₀[x@n ≔ e] = T₁
    ──────────────────────────────────────
    ([] : List T₀)[x@n ≔ e] = [] : List T₁


    t₀[x@n ≔ e] = t₁   …
    ────────────────────────────────
    ([ t₀, … ])[x@n ≔ e] = [ t₁, … ]


    T₀[x@n ≔ e] = T₁
    ──────────────────────────────────────────────
    ([] : Optional T₀)[x@n ≔ e] = [] : Optional T₁


    t₀[x@n ≔ e] = t₁   T₀[x@n ≔ e] = T₁
    ──────────────────────────────────────────────────────
    ([ t₀ ] : Optional T₀)[x@n ≔ e] = [ t₁ ] : Optional T₁


    t₀[x@n ≔ e] = t₁   T₀[x@n ≔ e] = T₁
    ───────────────────────────────────
    (t₀ : T₀)[x@n ≔ e] = t₁ : T₁


    l₀[x@n ≔ e] = l₁   r₀[x@n ≔ e] = r₁
    ───────────────────────────────────
    (l₀ || r₀)[x@n ≔ e] = l₁ || r₁


    l₀[x@n ≔ e] = l₁   r₀[x@n ≔ e] = r₁
    ───────────────────────────────────
    (l₀ + r₀)[x@n ≔ e] = l₁ + r₁


    l₀[x@n ≔ e] = l₁   r₀[x@n ≔ e] = r₁
    ───────────────────────────────────
    (l₀ ++ r₀)[x@n ≔ e] = l₁ ++ r₁


    l₀[x@n ≔ e] = l₁   r₀[x@n ≔ e] = r₁
    ───────────────────────────────────
    (l₀ # r₀)[x@n ≔ e] = l₁ # r₁


    l₀[x@n ≔ e] = l₁   r₀[x@n ≔ e] = r₁
    ───────────────────────────────────
    (l₀ && r₀)[x@n ≔ e] = l₁ && r₁


    l₀[x@n ≔ e] = l₁   r₀[x@n ≔ e] = r₁
    ───────────────────────────────────
    (l₀ ∧ r₀)[x@n ≔ e] = l₁ ∧ r₁


    l₀[x@n ≔ e] = l₁   r₀[x@n ≔ e] = r₁
    ───────────────────────────────────
    (l₀ ⫽ r₀)[x@n ≔ e] = l₁ ⫽ r₁


    l₀[x@n ≔ e] = l₁   r₀[x@n ≔ e] = r₁
    ───────────────────────────────────
    (l₀ * r₀)[x@n ≔ e] = l₁ * r₁


    l₀[x@n ≔ e] = l₁   r₀[x@n ≔ e] = r₁
    ───────────────────────────────────
    (l₀ == r₀)[x@n ≔ e] = l₁ == r₁


    l₀[x@n ≔ e] = l₁   r₀[x@n ≔ e] = r₁
    ───────────────────────────────────
    (l₀ != r₀)[x@n ≔ e] = l₁ != r₁


    f₀[x@n ≔ e] = f₁   a₀[x@n ≔ e] = a₁
    ───────────────────────────────────
    (f₀ a₀)[x@n ≔ e] = f₁ a₁


    ──────────────────
    n.n[x@n ≔ e] = n.n


    ────────────────
    +n[x@n ≔ e] = +n


    ──────────────
    n[x@n ≔ e] = n


    ──────────────────
    "…"[x@n ≔ e] = "…"


    T₀[x@n ≔ e] = T₁   …
    ──────────────────────────────────────
    { x : T₀, … }[x@n ≔ e] = { x : T₁, … }


    t₀[x@n ≔ e] = t₁   …
    ──────────────────────────────────────
    { x = t₀, … }[x@n ≔ e] = { x = t₁, … }


    t₀[x@n ≔ e] = t₁   T₀[x@n ≔ e] = T₁   …
    ──────────────────────────────────────────────────────────
    < x = t₀ | y : T₀ | … >[x@n ≔ e] = < x = t₁ | y : T₁ | … >


    ──────────────────────────────────────
    Natural/build[x@n ≔ e] = Natural/build


    ────────────────────────────────────
    Natural/fold[x@n ≔ e] = Natural/fold


    ────────────────────────────────────────
    Natural/isZero[x@n ≔ e] = Natural/isZero


    ────────────────────────────────────
    Natural/even[x@n ≔ e] = Natural/even


    ──────────────────────────────────
    Natural/odd[x@n ≔ e] = Natural/odd


    ──────────────────────────────────────────────
    Natural/toInteger[x@n ≔ e] = Natural/toInteger


    ────────────────────────────────────
    Natural/show[x@n ≔ e] = Natural/show


    ────────────────────────────────────
    Integer/show[x@n ≔ e] = Integer/show


    ──────────────────────────────────
    Double/show[x@n ≔ e] = Double/show


    ────────────────────────────────
    List/build[x@n ≔ e] = List/build


    ──────────────────────────────
    List/fold[x@n ≔ e] = List/fold


    ──────────────────────────────────
    List/length[x@n ≔ e] = List/length


    ──────────────────────────────
    List/head[x@n ≔ e] = List/head


    ──────────────────────────────
    List/last[x@n ≔ e] = List/last


    ────────────────────────────────────
    List/indexed[x@n ≔ e] = List/indexed


    ────────────────────────────────────
    List/reverse[x@n ≔ e] = List/reverse


    ──────────────────────────────────────
    Optional/fold[x@n ≔ e] = Optional/fold


    ────────────────────────────────────────
    Optional/build[x@n ≔ e] = Optional/build


    ────────────────────
    Bool[x@n ≔ e] = Bool


    ────────────────────────────
    Optional[x@n ≔ e] = Optional


    ──────────────────────────
    Natural[x@n ≔ e] = Natural


    ─────────────────────────
    Intger[x@n ≔ e] = Integer


    ────────────────────────
    Double[x@n ≔ e] = Double


    ────────────────────
    Text[x@n ≔ e] = Text


    ────────────────────
    List[x@n ≔ e] = List


    ────────────────────
    True[x@n ≔ e] = True


    ──────────────────────
    False[x@n ≔ e] = False


    ────────────────────
    Type[x@n ≔ e] = Type


    ────────────────────
    Kind[x@n ≔ e] = Kind


## Normalization

Normalization is a function of the following form:

    t₀ ⇥ t₁

... where:

* `t₀` is the expression to normalize
* `t₁` is the normalized expression

Normalization evaluates all β-reducible expressions:

    (λ(x : Bool) → x != False) True ⇥ False

Normalization also evaluates all built-in functions if they are fully saturated:

    List/length Integer [1, 2, 3] ⇥ +3

Normalization works under λ, meaning that the body of an unapplied λ-expression
can be normalized:

    λ(x : Bool) → List/length Integer [1, 2, 3] ⇥ λ(x : Bool) → +3

Dhall is a total language that is strongly normalizing, so evaluation order has
no effect on the language semantics and a conforming implementation can select
any evaluation strategy.

Also, note that the semantics specifies several built-in functions and operators
that conforming implementations must support.  Implementations are encouraged to
implement the following functions and operators in more efficient ways than the
following reduction rules so long as the result of normalization is the same.

The first normalization rule specifies how β-reduction behaves:

    f ⇥ λ(x : A) → b₀
    ↑(1, x, 0, a₀) = a₁
    b₀[x ≔ a₁] = b₁
    ↑(-1, x, 0, b₁) = b₂
    b₂ ⇥ b₃
    ──────────────────────
    f a₀ ⇥ b₃


An expression of the form:

    let x : A = a₀ in b₀

... is semantically identical to:

    (λ(x : A) → b₀) a₀

... and the normalization rules for `let` expressions reflect that semantic
equivalence:


    ↑(1, x, 0, a₀) = a₁
    b₀[x ≔ a₁] = b₁
    ↑(-1, x, 0, b₁) = b₂
    b₂ ⇥ b₃
    ─────────────────────────
    let x : A = a₀ in b₀ ⇥ b₃


    ↑(1, x, 0, a₀) = a₁
    b₀[x ≔ a₁] = b₁
    ↑(-1, x, 0, b₁) = b₂
    b₂ ⇥ b₃
    ─────────────────────
    let x = a₀ in b₀ ⇥ b₃


`if` expressions are the canonical way to eliminate a `Bool`:


    t ⇥ True   l₀ ⇥ l₁
    ────────────────────────
    if t then l₀ else r ⇥ l₁


    t ⇥ False   r₀ ⇥ r₁
    ────────────────────────
    if t then l else r₀ ⇥ r₁


`merge` expressions are the canonical way to eliminate a union literal.  The
first argument to `merge` is a record of handlers and the second argument is a
union value.  You apply the handler of the same label to the selected value of
the union literal:


    t ⇥ { x = f, … }   u ⇥ < x = a | y : T | … >   f a ⇥ e
    ──────────────────────────────────────────────────────
    merge t u : T ⇥ e


    t ⇥ { x = f, … }   u ⇥ < x = a | y : T | … >   f a ⇥ e
    ──────────────────────────────────────────────────────
    merge t u ⇥ e


Normalizing a type annotation is the same as removing the type annotation:


    t ⇥ e
    ─────────
    t : T ⇥ e


Boolean operators behave in the standard way:


    l ⇥ False   r ⇥ e
    ─────────────────
    l || r ⇥ e


    l ⇥ True
    ─────────────
    l || r ⇥ True


    l ⇥ True   r ⇥ e
    ────────────────
    l && r ⇥ e


    l ⇥ False
    ──────────────
    l && r ⇥ False



Natural number addition is defined via induction, but you will probably want to
use machine arithmetic in a real implementation for efficiency:


    l ⇥ +0   r ⇥ e
    ──────────────
    l + r ⇥ e


    l₀ ⇥ +1 + l₁   l₁ + r ⇥ e
    ─────────────────────────
    l₀ + r ⇥ +1 + e


Natural number multiplication is also defined via induction, but you will
probably want to use machine arithmetic here, too:


    l ⇥ +0
    ──────────
    l * r ⇥ +0


    l₀ ⇥ +1 + l₁   r₀ ⇥ r₁   l₁ * r₀ ⇥ e
    ────────────────────────────────────
    l₀ * r₀ ⇥ r₁ + e


String concatenation is also defined via induction, but real implementations
will use a more efficient approach:


    r ⇥ e
    ───────────
    "" ++ r ⇥ e


    l ++ r ⇥ e
    ──────────────────────────
    ("." ++ l) ++ r ⇥ "." ++ e


Normalizing a list normalizes each field.  Lists are defined via induction as
if they were linked lists, but a real implementation might represent them using
another data structure under the hood:


    T₀ ⇥ T₁
    ──────────────────────────
    [] : List T₀ ⇥ [] : List T₁


    x₀ ⇥ x₁   xs₀ ⇥ xs₁
    ──────────────────────────
    [ x₀, xs₀… ] ⇥ [ x₁, xs₁… ]


`List` concatenation is also defined via induction:


    ls ⇥ [] : List T   rs ⇥ es
    ─────────────────────────
    ls # rs ⇥ es


    ls₀ ⇥ [ l₁, ls₁… ]   l₁ ⇥ l₂  ls₁… # rs ⇥ es
    ───────────────────────────────────────
    ls₀ # rs ⇥ [ l₂ ] # es


Normalizing a record normalizes each field:


    ───────
    {} ⇥ {}


    t₀ ⇥ t₁   r₀… ⇥ r₁…
    ───────────────────────────────
    { x = t₀, r₀… } ⇥ { x = t₁, r₁… }


Recursive record merge combines two records, recursively merging any fields that
collide.  The type system ensures that colliding fields must be records:


    r ⇥ e
    ──────────
    {} ∧ r ⇥ e


    a ∧ b ⇥ t   l… ∧ r… ⇥ u
    ─────────────────────────────────────
    { x = a, l… } ∧ { x = b, r… } ⇥ t ∧ u


    a₀ ⇥ a₁   l… ∧ r ⇥ u
    ──────────────────────────────────  ; x ∉ r
    { x = a₀, l… } ∧ r ⇥ { x = a₁, u }


Right-biased record merge is non-recursive.  Field collisions are resolved by
preferring the field from the right record and discarding the colliding field
from the left record:


    r ⇥ e
    ──────────
    {} ⫽ r ⇥ e


    b₀ ⇥ b₁   l ∧ r ⇥ t
    ────────────────────────────────────────────
    { x = a, l } ∧ { x = b₀, r } ⇥ { x = b₁, t }


    a₀ ⇥ a₁   l ∧ r ⇥ t
    ─────────────────────────────────  ; x ∉ r
    { x = a₀, l } ∧ r ⇥ { x = a₁, t }


The `Natural/fold` function is the canonical elimination function for natural
numbers:


    t₀ ↠ Natural/fold m B f b   m ↠ +0   b ⇥ t₁
    ───────────────────────────────────────────
    t₀ ⇥ t₁


    t₀ ↠ Natural/fold m B f b   m ↠ +1 + n   f (Natural/fold n B f b) ⇥ t₁
    ──────────────────────────────────────────────────────────────────────
    t₀ ⇥ t₁


`Natural/build` is the canonical introduction function for `Natural` numbers and
is the inverse of `Natural/fold`, which leads to the following rules for
`build/fold` fusion:


    t₀ ↠ Natural/build t₁
    t₁ ↠ Natural/fold t₂
    t₂ ⇥ t₃
    ─────────────────────
    t₀ ⇥ t₃


    t₀ ↠ Natural/fold t₁
    t₁ ↠ Natural/build t₂
    t₂ ⇥ t₃
    ─────────────────────
    t₀ ⇥ t₃


In the absence of fusion, `Natural/build` falls back on the following rule:


    t₀ ↠ Natural/build f   f Natural (λ(x : Natural) → x + +1) +0 ⇥ t₁
    ──────────────────────────────────────────────────────────────────
    t₀ ⇥ t₁


`Natural/isZero` detects whether or not a `Natural` number is `+0`:


    t₀ ↠ Natural/isZero t₁   t₁ ↠ +0
    ────────────────────────────────
    t₀ ⇥ True


    t₀ ↠ Natural/isZero t₁   t₁ ↠ +1 + n
    ────────────────────────────────────
    t₀ ⇥ False


`Natural/even` detects whether or not a `Natural` number is even:


    t₀ ↠ Natural/even t₁   t₁ ↠ +0
    ──────────────────────────────
    t₀ ⇥ True


    t₀ ↠ Natural/even t₁   t₁ ↠ +1
    ──────────────────────────────
    t₀ ⇥ False


    t₀ ↠ Natural/even t₁   t₁ ↠ t₂ + +1   Natural/odd t₂ ⇥ t₃
    ─────────────────────────────────────────────────────────
    t₀ ⇥ t₃


`Natural/odd` detects whether or not a `Natural` number is off:


    t₀ ↠ Natural/odd t₁   t₁ ↠ +0
    ──────────────────────────────
    t₀ ⇥ False


    t₀ ↠ Natural/odd t₁   t₁ ↠ +1
    ──────────────────────────────
    t₀ ⇥ True


    t₀ ↠ Natural/odd t₁   t₁ ↠ t₂ + +1   Natural/even t₂ ⇥ t₃
    ─────────────────────────────────────────────────────────
    t₀ ⇥ t₃


`Natural/toInteger` transforms a `Natural` number into the corresponding
`Integer`:


    t₀ ↠ Natural/toInteger t₁   t₁ ↠ +n
    ───────────────────────────────────
    t₀ ⇥ n


`Natural/show` transforms a `Natural` number into a `Text` literal representing
valid Dhall code for representing that `Natural` number:


    t₀ ↠ Natural/show t₁   t₁ ↠ +n
    ──────────────────────────────
    t₀ ⇥ "+n"


`Integer/show` transforms an `Integer` into a `Text` literal representing valid
Dhall code for representing that `Integer` number:


    t₀ ↠ Integer/show t₁   t₁ ↠ n
    ─────────────────────────────
    t₀ ⇥ "n"


`Double/show` transforms a `Double` into a `Text` literal representing valid
Dhall code for representing that `Double` number:


    t₀ ↠ Double/show t₁   t₁ ↠ n.n
    ──────────────────────────────
    t₀ ⇥ "n.n"


`List/fold` is the canonical elimination function for `List`s:


    t₀ ↠ List/fold A₀ t₁ B f b   t₁ ↠ [] : List A₁   b ⇥ t₂
    ───────────────────────────────────────────────────────
    t₀ ⇥ t₂


    t₀ ⇥ List/fold A₀ t₁ B f b   t₁ ↠ [ a, … ]   f a (List/fold A₀ … B f b) ⇥ t₂
    ────────────────────────────────────────────────────────────────────────────
    t₀ ⇥ t₂


`List/build` is the canonical introduction function for `List`s and is the
inverse of `List/fold`, which leads to the following rules for `build/fold`
fusion:


    t₀ ↠ List/fold A₀ t₁   t₁ ↠ List/build A₁ t₂   t₂ ⇥ t₃
    ──────────────────────────────────────────────────────
    t₀ ⇥ t₃


    t₀ ↠ List/build A₀ t₁   t₁ ↠ List/fold A₁ t₂   t₂ ⇥ t₃
    ──────────────────────────────────────────────────────
    t₀ ⇥ t₃



In the absence of fusion, `List/build` falls back on the following rule:


    t₀ ↠ List/build A t₁
    t₁ (List A) (λ(a : A) → λ(as : List a) → [ a ] # as) ([] : List A) ⇥ t₂
    ───────────────────────────────────────────────────────────────────────
    t₀ ⇥ t₂


`List/length` returns the length of a list:


    t₀ ↠ List/length A₀ t₁   t₁ ↠ [] : List A₁
    ──────────────────────────────────────────
    t₀ ⇥ +0


    t₀ ↠ List/length A₀ t₁   t₁ ↠ [ a, … ]   +1 + List/length A₀ … ⇥ t₂
    ───────────────────────────────────────────────────────────────────
    t₀ ⇥ t₂


`List/head` returns the first element of a list:


    t₀ ↠ List/head A₀ t₁   t₁ ↠ [] : List A₁   [] : Optional A₀ ⇥ t₂
    ────────────────────────────────────────────────────────────────
    t₀ ⇥ t₂


    t₀ ↠ List/head A₀ t₁   t₁ ↠ [ a, … ]   [ a ] : Optional A₀ ⇥ t₂
    ───────────────────────────────────────────────────────────────
    t₀ ⇥ t₂


`List/last` returns the last element of a list:


    t₀ ↠ List/last A₀ t₁   t₁ ↠ [] : List A₁   [] : Optional A₀ ⇥ t₂
    ────────────────────────────────────────────────────────────────
    t₀ ⇥ t₂


    t₀ ↠ List/last A₀ t₁   t₁ ↠ [ …, a ]   [ a ] : Optional A₀ ⇥ t₂
    ───────────────────────────────────────────────────────────────
    t₀ ⇥ t₂


`List/indexed` tags each element of the list with the element's index:


    t₀ ↠ List/indexed A₀ t₁
    t₁ ↠ [] : List A₁
    [] : List { index : Natural, value : A₀ } ⇥ t₂
    ──────────────────────────────────────────────
    t₀ ⇥ t₂


    t₀ ↠ List/indexed A₀ t₁
    t₁ ↠ [ a₀, … ]
    [ { index = +0, value = a₀ }, … ] : List { index : Natural, value : A₀ } ⇥ t₂
    ─────────────────────────────────────────────────────────────────────────────
    t₀ ⇥ t₂


`List/reverse` reverses the elements of the list:


    t₀ ↠ List/reverse A₀ t₁   t₁ ↠ [] : List A₁   [] : List A₀ ⇥ t₂
    ───────────────────────────────────────────────────────────────
    t₀ ⇥ t₂

    t₀ ↠ List/reverse A₀ t₁   t₁ ↠ [ a, … ]   [ …, a ] : List A₀ ⇥ t₂
    ─────────────────────────────────────────────────────────────────
    t₀ ⇥ t₂


`Optional/fold` is the canonical elimination function for `Optional` values:


    t₀ ↠ Optional/fold A₀ t₁ B₀ f b   t₁ ⇥ [ a ] : Optional A₁   f a ⇥ t₂
    ─────────────────────────────────────────────────────────────────────
    t₀ ⇥ t₂

    t₀ ↠ Optional/fold A₀ t₁ B₀ f b   t₁ ↠ [] : Optional A₁   b ⇥ t₂
    ────────────────────────────────────────────────────────────────
    t₀ ⇥ t₂


`Optional/build` is the canonical introduction function for `Optional` values and
is the inverse of `Optional/fold`, which leads to the following rules for
`build/fold` fusion:


    t₀ ↠ Optional/fold A₀ t₁   t₁ ↠ Optional/build A₁ t₂   t₂ ⇥ t₃
    ──────────────────────────────────────────────────────────────
    t₀ ⇥ t₃


    t₀ ↠ Optional/build A₀ t₁   t₁ ↠ Optional/fold A₁ t₂   t₂ ⇥ t₃
    ──────────────────────────────────────────────────────────────
    t₀ ⇥ t₃


In the absence of fusion, `Optional/build` falls back on the following rule:


    t₀ ↠ Optional/build A t₁
    t₁ (Optional A) (λ(a : A) → [ a ] : Optional A) ([] : Optional A) ⇥ t₂
    ─────────────────────────────────────────────────────────────────────
    t₀ ⇥ t₂


## αβ-equivalence

αβ-equivalence is a relationship between two expression of the form:

    e₀ =ᵦ e₁

Expressions are αβ-equivalent if they are α-equivalent when fully β-reduced.
You can fully β-reduce an expression by applying the following β-reduction rule
anywhere within the expression until no β-reducible expressions remain:


    ↑(1, x, 0, a₀) = a₁   b₀[x ≔ a₁] = b₁   ↑(-1, x, 0, b₁) = b₂
    ────────────────────────────────────────────────────────────
    (λ(x : A) → b₀) a₀ =ᵦ b₂


The order in which you β-reduce expressions does not matter
Two expression are both α

## Kind check

The kind check governs which types of functions that our pure type system
permits

Dhall forbids dependent function types, but permits all other function
types 

The following rule enables support for functions from terms to terms (i.e.
"term-level" functions):


    ─────────────
    ⊢ Type ↝ Type


For example, these are term-level functions:

    Natural/even

    λ(x : Bool) → x != False


The following rule enables support for functions from types to terms (i.e.
"polymorphic" functions):


    ─────────────
    ⊢ Kind ↝ Type


For example, these are polymorphic functions:

    List/head

    λ(a : Type) → λ(x : a) → x

THe following rule enables support for functions from types to types (i.e.
"type-level" functions):


    ─────────────
    ⊢ Kind ↝ Kind


For example, these are type-level functions:

    List

    λ(m : Type) → [ m ] → m


However, Dhall does not support dependently-typed functions, so there is no rule
for `⊢ Type ↝ Kind`.  Dhall omits support for dependent function types because
that would entail detecting non-trivial type-level equalities.

## Type inference

Type inference is a judgment of the form:

    Γ ⊢ t : T

... where:

* `Γ` is the type inference context which relates identifiers to their types
* `t` is the term to infer the type of
* `T` is the inferred type

To infer the type of a closed expression, supply an empty context:

    ε ⊢ t : T

### Reduction

Additionally, there is a separate helper judgment for inferring a type reduced
to weak head normal form:


    Γ ⊢ a : A   A ↠ B
    ─────────────────
    Γ ⊢ a :↠ B


This judgment is essentially identical to the judgment for type inference except
that this judgment guarantees that the inferred type is in weak head normal
form.

### Types and Kinds

The first rule is that the inferred type of `Type` is `Kind`, no matter the
context:


    ───────────────
    ε ⊢ Type : Kind


In other words, `Kind` is the "type of types" and `Kind` serves as the
foundation of the type system.  Note that you cannot infer the type of `Kind`
as there is nothing above `Kind` in the type system's hierarchy.  Inferring the
type of `Kind` is a type error.

### Variables

You can infer the type of a variable by looking up the variable's type in the
context:


    Γ ⊢ T : k
    ──────────────────
    Γ, x : T ⊢ x@0 : T


Since `x` is a synonym for `x@0`, you can shorten this rule to:


    Γ ⊢ T : k
    ──────────────────
    Γ, x : T ⊢ x : T


The order of types in the context matters because there can be multiple type
annotations in the context for the same variable.  The natural number associated
with each variable disambiguates which type annotation in the context to use:


    Γ ⊢ A : k   Γ ⊢ x@n : T
    ─────────────────────────  ; 0 < n
    Γ, x : A ⊢ x@(+1 + n) : T


    Γ ⊢ A : k   Γ ⊢ x@n : T
    ───────────────────────  ; x ≠ y
    Γ, y : A ⊢ x@n : T


If the natural number associated with the variable is greater than or equal to
the number of type annotations in the context matching the variable then that is
a type error

Carefully note that the above two rules imply that each type stored in the
context must be well-typed.  This restriction ensures that we can safely
normalize any type retrieved from the context since well-typed terms will not
infinitely loop if normalized.

### Lambdas

You can create new (anonymous) functions using a λ:


    ↑(1, x, 0, (Γ₀, x : A)) = Γ₁   Γ₁ ⊢ b : B   Γ₀ ⊢ ∀(x : A) → B : k
    ─────────────────────────────────────────────────────────────────
    Γ₀ ⊢ λ(x : A) → b : ∀(x : A) → B


The type of a λ-expression is a function type whose input type (`A`) is the same
as the type of the bound variable and whose output type (`B`) is the same as the
inferred type of the body of the λ-expression (`b`).

Carefully note that the above rule requires that the inferred function type must
be well-typed.  The type-checking step for the function type disallows certain
types of functions.

### Function types

A function type is only well-typed if the input and output type are well-typed:


    Γ₀ ⊢ A :↠ i   ↑(1, x, 0, (Γ₀, x : A)) = Γ₁   Γ₁ ⊢ B :↠ o   ⊢ i ↝ o
    ──────────────────────────────────────────────────────────────────
    Γ₀ ⊢ ∀(x : A) → B : o


... and if the inferred kinds of the input and output type are allowed.  This
kind check disallows dependent function types.

The unquantified function type `A → B` is a short-hand for `∀(_ : A) → B`.  Note
that the `_` does **NOT** denote some unused type variable but rather denotes
the specific variable named `_` (which is a valid variable name and this
variable named `_` may in fact be present within `B`).  For example, this is a
well-typed judgment:

    ε ⊢ Type → _ : Kind

... because it is equivalent to:

    ε ⊢ ∀(_ : Type) → _ : Kind

### Function application

The type system ensures that function application is well-typed, meaning that
the input type that a function expects matches the inferred type of the
function's argument:


    Γ ⊢ f :↠ ∀(x : A₀) → B₀
    Γ ⊢ a : A₁
    A₀ =ᵦ A₁
    ↑(1, x, 0, a₀) = a₁
    B₀[x ≔ a₁] = B₁
    ↑(-1, x, 0, B₁) = B₂
    ────────────────────────────────────────────
    Γ ⊢ f a₀ : B₂


If the inferred input type of the function does not match the inferred type of
the function argument then that is a type error

Carefully note that you should not check `A₀ =ᵦ A₁` until you have first checked
the two other preconditions.  This is because a β-equivalence check might not
terminate if one of `A₀` or `A₁` is not well-typed

### `let` expressions


    Γ₀ ⊢ a₀ : A₁
    Γ₀ ⊢ A₀ :↠ i
    A₀ =ᵦ A₁
    ↑(1, x, 0, (Γ₀, x : A₀)) = Γ₁
    Γ₁ ⊢ b : B₀
    Γ₁ ⊢ B₀ :↠ o
    ⊢ i ↝ o
    ↑(1, x, 0, a₀) = a₁
    B₀[x ≔ a₁]) = B₁
    ↑(-1, x, 0, B₁) = B₂
    ──────────────────────────────
    Γ₀ ⊢ let x : A₀ = a₀ in b : B₂


    Γ₀ ⊢ a₀ : A
    Γ₀ ⊢ A :↠ i
    ↑(1, x, 0, (Γ₀, x : A)) = Γ₁
    Γ₁ ⊢ b : B₀
    Γ₁ ⊢ B ₀:↠ o
    ⊢ i ↝ o
    ↑(1, x, 0, a₀) = a₁
    B₀[x ≔ a₁] = B₁
    ↑(-1, x, 0, B₁) = B₂
    ────────────────────────────
    Γ₀ ⊢ let x = a₀ in b : B₂


### `if`/`then`/`else`


    Γ ⊢ t :↠ Bool
    Γ ⊢ l : L
    Γ ⊢ r : R
    Γ ⊢ L :↠ Type
    Γ ⊢ R :↠ Type
    L =ᵦ R
    ──────────────────────────
    Γ ⊢ if t then l else r : L


### `merge`




# TODO

* Use … notation more precisely
* Fix `=ᵦ` to include `α`
* Flesh out αβ-equivalence in more detail
* Does the valid context optimization from the Henk paper work?  If so, simplify
  typing judgments
* Reference Henk paper
